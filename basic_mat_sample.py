# -*- coding: utf-8 -*-
"""uniform_matrix_sample.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17mu9rqhd6b8Tfnn1Rk-NPQI6zSrG1Pz4
"""


import numpy as np
import itertools
import scipy as sp
import random
np.set_printoptions(precision=2, suppress=True)


path_n = 4
dim = 4

# ts_data = [0,0.4,0,0.6,0,0.5,0.5,0,0,0,1,0,0,0.8,0,0.2]
# ts_t0 = {k: v for k, v in zip(itertools.product(range(4), repeat=2), ts_data) if v != 0}

# row = [i for (i, j) in ts_t0.keys()]
# col = [j for (i, j) in ts_t0.keys()]
# vals = list(ts_t0.values())

ts_data = [0,1,0,1,0,1,1,0,0,0,1,0,0,2,0,0]
ts_t0 = {k: v for k, v in zip(itertools.product(range(4), repeat=2), ts_data) if v != 0}

row = [i for (i, j) in ts_t0.keys()]
col = [j for (i, j) in ts_t0.keys()]
vals = list(ts_t0.values())

g0 = sp.sparse.coo_array((vals, (row, col)), shape=(dim, dim), dtype=float).tocsr()
#g0 = sp.sparse.csr_array(np.arange(dim**2).reshape(4,4))

g0.toarray()
# g0 = torch.sparse_coo_tensor(values=vals, indices=(row, col), size=(n, n), dtype=float).to_sparse_csr()
# g0.to_dense()

# make ADDs
gs = [g0]
gi = g0
for i in range(1, int(np.log2(path_n))):
  gi = gi @  gi
  gs.append(gi)
  print(f"i = {i}")
  # print(gi.toarray())

"""$wtList[l]=val(v_l)*|\\Pi_{v_l}|$  
$|\\Pi_{v_l}|$ is number of paths from node to root
"""

def pathcount(g):
  n = g.shape[0]
  b = np.zeros([n,n,n])
  b[np.diag_indices(n,ndim=2)] = g
  return np.tensordot(g, b, axes=[1,0]) # type: ignore
g = gs[1].toarray()
res = pathcount(g)

ts = []
for i, gi in enumerate(gs):
  ti = pathcount(gi.toarray())
  ts.append(ti)
  print(f"i = {i}")
  # print(ti)

def weighted_idx_sample(mat):
  coords = list(zip(*np.nonzero(mat)))
  probs = mat[mat != 0]
  return random.choices(coords, weights=probs)[0]

def sample_mat(ti, lo, hi, w, init=[0],target=[]):
  mid = int(np.mean([lo,hi]))
  if w[hi] == -1: # first iteration
    opts = ti[init]
    if len(target) > 0:
        opts = opts[:, :,target]
    print(opts)
    asgn = weighted_idx_sample(opts)
    w[lo] = init[asgn[0]]
    w[mid] = asgn[1]
    w[hi] = target[asgn[2]]
    pass
  else:
    opts = ti[w[lo], :, w[hi]]
    asgn = weighted_idx_sample(opts)
    w[mid] = asgn[0]


def draw_sample(ts, init, target=[]):
  w = np.full(path_n+1, -1, dtype=int)
  w[0] = 0
  for i in range(int(np.log2(path_n)), 0, -1):
    inc = np.power(2, i)
    for j in range(0, path_n, inc):
      #print(f"mid = {int((j+j+inc)/2)}")
      #w[int((j+j+inc)/2)] = i
      sample_mat(ts[i-1], j, j + inc, w, init, target)
  return w


#w = sample_mat(np.log2(N), ts[-1], 0, N, w)
w = draw_sample(ts, [0],[2,3])

# Commented out IPython magic to ensure Python compatibility.
# %%time
repeats = 5000
results = {}
for i in range(repeats):
  t = tuple(draw_sample(ts, [0, 1],[2,3]))
  if t not in results:
    results[t] = 1
  else:
    results[t] += 1
legible = '\n'.join([','.join([str(i) for i in k]) + f' - {v}' for k, v in results.items()])
print(legible)

# import matplotlib.pyplot as plt
# plt.bar(results.keys(), results.values())