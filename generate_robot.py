
# Remember model is 1-idx

gridsize = (10, 5)
down_bumpers = [(i, 2) for i in range(2, 9)] + [(9, 1)]
up_bumpers = [(i, 4) for i in range(2, 9)] + [(9, 5)]


robot_init = (1,1)
robot_goal = (10, 4)
pickups = [(10, 1), (3, 5), (1,3)] # pickups on bumpers don't work
target_pickups = 2

filename = 'dtmcs/robot_auto.pm'

program_header = '''// Based on GRID WORLD MODEL OF ROBOT AND JANITOR
// Hakan Younes/gxn/dxp 04/05/04
// automatically generated by "generate_robot.py"
dtmc

// CONSTANTS
const int xn = {}; // size of the grid
const int yn = {};

// the following formulae return 1 or 0 depending on whether
// the robot can move in that direction or not
formula right = min(1,max(xn-x1,0));
formula left = min(1,max(x1-1,0));
formula up = min(1,max(yn-y1,0));
formula down = min(1,max(y1-1,0));

// total number of moves the robot randomly picks from
formula moves = right+left+up+down;
'''.format(*gridsize)

program_robot = '''module robot
	x1 : [1..xn] init 1; // x position of robot (bottom left)
	y1 : [1..yn] init 1; // y position of robot
	
	[move] true    -> up/moves:(y1'=y1+1) + down/moves:(y1'=y1-1) + left/moves:(x1'=x1-1) + right/moves:(x1'=x1+1); 
	[bump_down] ({}) & (down=1) -> 1: (y1'=y1-1);
    [bump_up] ({}) & (up=1) -> 1: (y1'=y1+1);
endmodule
'''.format('|'.join([f'on_db{i+1}' for i in range(len(down_bumpers))]),
           '|'.join([f'on_ub{i+1+len(down_bumpers)}' for i in range(len(up_bumpers))]))

pick_module = lambda i, pos: f'''module pickup{i}
	rx{i} : [1..xn] init {pos[0]};
	ry{i} : [1..yn] init {pos[1]};
	picked{i}: [0..1] init 0;
	[move] !on_pick{i} | picked{i}=1 -> 1: true;
	[move] on_pick{i} & picked{i}=0 -> 1: (picked{i}' = 1);
endmodule
formula on_pick{i} = rx{i} = x1 & ry{i} = y1;
'''

db_module = lambda i, pos: f'''module down_bumper{i}
	cx{i} : [1..xn] init {pos[0]};
	cy{i} : [1..yn] init {pos[1]};
	[bump_down] true -> 1: true;
	[move] !on_db{i} -> 1: true; 
endmodule
formula on_db{i} = cx{i} = x1 & cy{i} = y1;
'''

ub_module = lambda i, pos: f'''module up_bumper{i}
	cx{i} : [1..xn] init {pos[0]};
	cy{i} : [1..yn] init {pos[1]};
	[bump_up] true -> 1: true;
	[move] !on_ub{i} -> 1: true; 
endmodule
formula on_ub{i} = cx{i} = x1 & cy{i} = y1;
'''

pickup_sum = "+".join([f'picked{i}' for i in range(1, len(pickups)+1)])
target = 'label "target" = x1={} & y1={} & ({} >= {});'.format(*robot_goal, pickup_sum, target_pickups)

program_pick = '\n'.join([pick_module(i, pos) for i, pos in enumerate(pickups, 1)])
program_db = '\n'.join([db_module(i, pos) for i, pos in enumerate(down_bumpers, 1)])
program_ub = '\n'.join([ub_module(i, pos) for i, pos in enumerate(up_bumpers, 1+len(down_bumpers))])

with open(filename, 'w+') as f:
    f.writelines([program_header, program_robot,
                  program_pick, program_db, program_ub, target])
