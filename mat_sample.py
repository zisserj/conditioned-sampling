# -*- coding: utf-8 -*-
"""uniform_matrix_sample.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17mu9rqhd6b8Tfnn1Rk-NPQI6zSrG1Pz4
"""

import numpy as np
import itertools
import scipy as sp
import random
import pickle
np.set_printoptions(precision=2, suppress=True)
import argparse

parser = argparse.ArgumentParser("Precomutes and uniformly samples TS via matrix representaation.")
parser.add_argument("fname", help="Target mat pickle.", type=str)
args = parser.parse_args()
fname = args.fname


with open(fname, 'rb') as f:
    bdd_mat = pickle.load(f)

sp_bdd = sp.sparse.coo_array(bdd_mat, dtype=float).tocsr()
path_n = 8
dim = len(bdd_mat)

g0 = sp_bdd

# make ADDs
gs = [g0]
gi = g0
for i in range(1, int(np.log2(path_n))):
  gi = gi @  gi
  gs.append(gi)
#   print(f"i = {i}")
#   print(gi.toarray())


def pathcount(g):
  n = g.shape[0]
  b = np.zeros([n,n,n])
  b[np.diag_indices(n,ndim=2)] = g[np.diag_indices(n,ndim=2)]
  return np.tensordot(g, b, axes=[1,0])
g = gs[1].toarray()
res = pathcount(g)
res

def pathcount2(g):
  wide = sp.sparse.block_diag(g)
  mult = g @ wide
  n = g.shape[0]
  mult.idx = lambda i, j, k: mult[np.s_[i, j*(n)+k]]
  return mult
g = gs[1]
res2 = pathcount2(g)
res2.toarray()

ts = []
for i, gi in enumerate(gs):
  ti = pathcount(gi.toarray())
  ts.append(ti)
#   print(f"i = {i}")
#   print(ti)

# r = ts[2]
# r_s = sp.sparse.coo_array(r, dtype=int)

# ind = zip(*r_s.nonzero(), r_s.data)
# [i for i in ind]

def weighted_idx_sample(mat):
  coords = list(zip(*np.nonzero(mat)))
  probs = mat[mat != 0]
  return random.choices(coords, weights=probs)[0]

def sample_mat(ti, lo, hi, w):
  mid = int(np.mean([lo,hi]))
  if w[hi] == -1:
    opts = ti[w[lo]]
    asgn = weighted_idx_sample(opts)
    w[mid] = asgn[0]
    w[hi] = asgn[1]
    # weight index tuple in ti[w[lo]] to be hi
    pass
  else:
    opts = ti[w[lo], :, w[hi]]
    asgn = weighted_idx_sample(opts)
    w[mid] = asgn[0]

# sample from ADD


def draw_sample(ts):
  w = np.full(path_n+1, -1, dtype=int)
  w[0] = 1
  for i in range(int(np.log2(path_n)), 0, -1):
    inc = np.power(2, i)
    for j in range(0, path_n, inc):
      #print(f"mid = {int((j+j+inc)/2)}")
      #w[int((j+j+inc)/2)] = i
      sample_mat(ts[i-1], j, j + inc, w)
  return w


#t = sample_mat(np.log2(N), ts[-1], 0, N, w)
t = draw_sample(ts)
print(t)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# repeats = 5000
# results = {}
# for i in range(repeats):
#   t = tuple(draw_sample(ts))
#   if t not in results:
#     results[t] = 1
#   else:
#     results[t] += 1
# print(results)

